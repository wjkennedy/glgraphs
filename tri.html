<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas + D3 Force Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="graph.js"></script>
    <script src="tree.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh;}
    </style>
</head>
<body>
    <canvas></canvas>
    <div id="status" style="position: absolute; bottom: 10px; left: 10px; color: white; font-family: monospace; z-index: 100;">status</div>
    <script>
        const canvas = document.querySelector('canvas');
        const ctx = canvas.getContext('2d');        

        //const rule = 1062;
        //const rule = 2210;
        //const rule = 2222;
        //const rule = 2182; !
        //const rule = 2183;//
        //const rule = 2236;
        //const rule = 1111;
        //const rule = 618;
        //1033 4118 2199
//0b0100_0110_0010_0101 !        
//0b0100_0110_0010_0001 !
//0b0110_0110_0010_0001
//0b0101_0110_1100_1100
//0b0000_1100_1011_1100 - interesting

        const rule = 0b0000_1100_1011_1100;

        const graph = new GrowingGraph(rule);

        function forceManyBody(strength=-3, maxDist=2000) {
            let nodes;

            function force(alpha) {
                const {forces, indices, tree, centers} = calcForces(nodes, maxDist);
                force.tree = tree;
                force.centers = centers;
                const c = strength*alpha;
                for (let i=0; i<indices.length; ++i) {
                    const node = nodes[indices[i]];
                    node.vx += c*forces[i*3];
                    node.vy += c*forces[i*3+1];
                }

            }
            force.initialize = function(initNodes) {
                nodes = initNodes;
            }
            return force;
        }

        function forceLink({distance=15, iterations=4, strength=0.4}={}) {
            let nodes;

            function force(alpha) {
                for (let k=0; k<iterations; ++k) {
                    for (let i=0; i<nodes.length; ++i) {
                        const source = nodes[i];
                        for (n=0; n<source.length; ++n) {
                            const j = source[n]; 
                            if (i > j) continue;
                            const target = nodes[j];
                            let x = target.x + target.vx - source.x - source.vx;
                            let y = target.y + target.vy - source.y - source.vy;
                            let l = Math.max(Math.sqrt(x * x + y * y), 1.0);
                            l = (l - distance) / l * alpha * strength;
                            x *= l, y *= l;
                            target.vx -= x; target.vy -= y;
                            source.vx += x; source.vy += y;
                        }
                    }
                }
            }
            force.initialize = function(initNodes) {
                nodes = initNodes;
            }
            return force;
        }


        const simulation = d3.forceSimulation(graph.nodes)
            .force("link", forceLink())
            .force("charge", forceManyBody())
            //.force("center", d3.forceCenter().strength(0.05))
            //.force('y', d3.forceY().strength(0.01))
            .alphaTarget(1).velocityDecay(0.1).tick(100).stop();
    
        const softStates = [...graph.states];
        const softDivinging = [...graph.dividing];

        function grow() { 
            if (graph.nodes.length > 10000) return;
            const {nodes, links} = graph.grow();
            simulation.nodes(nodes);
            simulation.alpha(1);
            const delay = Math.max(100*Math.exp(-0.05*graph.lastGen), 50);
            //setTimeout(grow, delay);         
        }

        function accumPoints(tree) {
            const centers = new Float32Array(tree.nodes.length * 3);
            const mass = new Float32Array(tree.nodes.length);
            for (let ni=tree.nodes.length-1; ni>=0; --ni) {
                const node = tree.nodes[ni];
                mass[ni] = node.end - node.start;
                if (node.next == ni+1) { // leaf
                    for (let i=node.start; i<node.end; ++i) {
                        for (let c=0; c<3; ++c) {
                            centers[ni*3+c] += tree.points[i*3+c];
                        }
                    }
                } 
                if (node.parentIdx == ni) continue
                for (let c=0; c<3; ++c) {
                    centers[node.parentIdx*3+c] += centers[ni*3+c];
                }
            }
            for (let i=0; i<centers.length; ++i) {
                centers[i] /= mass[(i/3)|0];
            }
            return {centers, mass};
        }
    
        function calcForces(graphNodes, maxDist) {
            const pointN = graphNodes.length;
            let points = new Float32Array(pointN*3);
            for (let i=0; i<pointN; ++i) {
                const {x,y} = graphNodes[i];
                points[i*3] = x;
                points[i*3+1] = y;
            }
            const tree = new Octree(points);
            points = tree.points; // use points sorted by Octree
            const {centers} = accumPoints(tree);

            const maxW = Math.max(...tree.extent);
            const theta2 = 0.81; // Barnes-Hut theta squared
            const maxDist2 = maxDist*maxDist;

            const forces = new Float32Array(pointN*3);
            let nodeCount=0, pointCount=0, p;
            for (let pointI = 0; pointI < tree.pointN; ++pointI) {
                const [x,y,z] = points.subarray(pointI*3, pointI*3+3)
                for (let nodeI=0; nodeI<tree.nodes.length;) {
                    const node = tree.nodes[nodeI];
                    const w = maxW/(1<<node.level);
                    p=nodeI*3;
                    const dx=centers[p++]-x, dy=centers[p++]-y, dz=centers[p]-z;
                    const l2 = dx*dx + dy*dy + dz*dz;
                    const tooFar = maxDist2 < l2;
                    if (w*w < theta2*l2) {
                        // Far enough, treat as single body
                        nodeI = node.next;
                        if (tooFar) continue;
                        ++nodeCount;

                        const mass = node.end-node.start;
                        const c = mass / (1.0+l2);
                        p = pointI*3;
                        forces[p++] += c*dx; forces[p++] += c*dy; forces[p] += c*dz;
                    } else {
                        ++nodeI;
                        if (node.next == nodeI && !tooFar) { // leaf
                            ++pointCount;
                            for (let i=node.start*3; i<node.end*3; i+=3) {
                                const dx=points[i]-x, dy=points[i+1]-y, dz=points[i+2]-z;
                                const l2 = dx*dx + dy*dy + dz*dz;
                                const c = 1.0 / (1.0+l2);
                                p = pointI*3;
                                forces[p++] += c*dx; forces[p++] += c*dy; forces[p] += c*dz;
                            }
                        }
                    }
                }
            }
            const status = document.getElementById('status');
            status.innerText = `nc:${nodeCount}, pc:${pointCount}`;
            return {forces, indices:tree.indices, tree, centers};
        }

        const status = document.getElementById('status');

        function frame(time) {
            if (time > 500) grow();
            simulation.tick(2);
        
            for (let i=0; i<graph.states.length; i++) {
                softStates[i] = (softStates[i]||0)*0.8 + graph.states[i]*0.2;
                softDivinging[i] = (softDivinging[i]||0)*0.8 + (graph.dividing[i]||0)*0.2;
            }
            const DPR = devicePixelRatio;
            const width = canvas.width = window.innerWidth*DPR;
            const height = canvas.height = window.innerHeight*DPR;

            let {tree, centers} = simulation.force('charge');
            if (!tree) return; // tree might not be initialized on first render

            const {bounds, extent} = tree;
            const padding = 0.95;
            const scale = padding * Math.min(width / (extent[0] || 1), height / (extent[1] || 1));

            const translateX = (width - extent[0] * scale) / 2 - bounds.lo[0] * scale;
            const translateY = (height - extent[1] * scale) / 2 - bounds.lo[1] * scale;

            ctx.resetTransform()
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);
            ctx.transform(scale, 0, 0, scale, translateX, translateY);

            // Draw links
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1/scale;
            ctx.beginPath();
            graph.links.forEach(d => {
                ctx.moveTo(d.source.x, d.source.y);
                ctx.lineTo(d.target.x, d.target.y);
            });
            ctx.stroke();
            
            // Draw nodes
            const cmap = d3.scaleSequential(d3.interpolatePlasma).domain([0, graph.lastGen+1]);
            ctx.strokeStyle = '#fff';

            //console.log(scale);
            graph.nodes.forEach((d,i) => {
                ctx.fillStyle = cmap(d.gen);
                ctx.beginPath();
                const r = (5+softDivinging[i]*3) / Math.min(scale*2., 1.0);
                ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
                ctx.fill();
                //ctx.lineWidth = 0.001+1.0*softStates[i];
                //ctx.stroke;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(d.x, d.y, softStates[i]*r*0.6, 0, Math.PI * 2);
                ctx.fill()
            });
            
            if (1) {
                ctx.lineWidth = 1/scale;
                ctx.strokeStyle = '#5f5';
                ctx.fillStyle = 'rgba(40,200,40,0.5)';
                for (let i=0; i<tree.nodes.length; ++i) {
                    //if (tree.nodes[i].next != i+1) continue; // skip non-leaves
                    const node = tree.nodes[i];
                    const [x, y] = node.pos;
                    const s = 1<<node.level;
                    const [w, h] = tree.extent;
                    ctx.strokeRect(x, y, w/s, h/s);
                    const cx=centers[i*3], cy=centers[i*3+1];
                    const mass = node.end-node.start;
                    ctx.beginPath()
                    ctx.arc(cx, cy, 4*Math.sqrt(mass), 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath()
                    ctx.moveTo(cx, cy);
                    const pi = node.parentIdx;
                    const px=centers[pi*3], py=centers[pi*3+1];
                    ctx.lineTo(px, py);
                    ctx.stroke()
                    
                }
            }

            ctx.resetTransform();
            ctx.font = "50px Arial";
            ctx.fillStyle = "#fff";
            ctx.fillText(`node n: ${graph.nodes.length}`,40,60);
            ctx.fillStyle = "#aaa";
            ctx.fillText(`rule: ${rule}`,40,120);
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
        //setTimeout(grow, 100);
    </script>
</body>
</html>